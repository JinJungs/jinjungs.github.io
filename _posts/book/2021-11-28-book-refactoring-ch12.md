---
title: "[리팩터링 2판] 12. 상속 다루기"
date: 2021-11-28 07:00:28 +0900
excerpt: "마지막 장에서는 객체 지향 프로그래밍에서 가장 유명한 특성인 상속에 대한 리팩터링을 알아보자."
categories:
  - book
tags:
  - refactoring
  - javascript
header:
  teaser: "../../img/book/refactoring.jpg"
---







마지막 장에서는 객체 지향 프로그래밍에서 가장 유명한 특성인 상속을 다룬다.  
다른 강력한 매커니즘처럼 이 역시 아주 유용한 동시에 오용하기 쉽다.
{: .notice--info}



<br/>

## 12.1. 메서드 올리기

### 배경

- 메서드 올리기를 적용하기 가장 쉬운 상황은 메서드의 본문 코드가 똑같을 때다. 그러나 언제나 이처럼 만만하지는 않다.
  - 각각 함수를 매개변수화 한 다음 메서드를 상속 계층으로 올리기
  - 필드들이 서브클래스에만 있는 경우 필드를 먼저 슈퍼클래스로 올린 후 메서드 올리기
  - 두 메서드의 전체 흐름은 비슷하지만 세부 내용이 다르다면 템플릿 메서드 만들기



<br/>

## 12.2. 필드 올리기

### 배경

- 특히 필드가 중복되기 쉽다.
- 분석 결과 필드들이 비슷한 방식으로 쓰인다고 판단되면 슈퍼클래스로 끌어올리자.



<br/>

## 12.3. 생성자 본문 올리기

### 배경

- 올려야할 메서드가 생성자라면 스텝이 꼬인다. 
  - 생성자는 할 수 있는 일과 호출 순서에 제약이 있기 때문에 조금 다른 식으로 접근해야 한다.



<br/>

## 12.4. 메서드 내리기

### 배경

- 특정 서브클래스 하나(혹은 소수)와만 관련된 메서드는 슈퍼클래스에서 제거하고 해당 서브클래스에만 추가하는 편이 깔끔하다.



<br/>

## 12.5. 필드 내리기

### 배경

- 서브클래스 하나(혹은 소수)에서만 사용하는 필드는 해당 서브클래스로 옮긴다.



<br/>

## 12.6. 타입 코드를 서브클래스로 바꾸기

### 배경

- 서브클래스는 두 가지 면에서 특히 매력적이다.
- 조건에 따라 다르게 동작하도록 해주는 다형성을 제공한다.
  - 타입코드에 따라 동작이 달라져야하는 함수가 여러 개일 때 특히 유용하다.
- 특정 타입에서만 의미가 있는 값을 사용하는 필드나 메서드가 있을 때
  - 서브 클래스를 만들고 필요한 서브클래스만 필드를 갖도록 정리하자.



<br/>

## 12.7. 서브클래스 제거하기

### 배경

- 쓰이지 않는 서브클래스는 제거하자



<br/>

## 12.8. 슈퍼클래스 추출하기

### 배경

- 비슷한 일을 수행하는 두 클래스가 보이면 상속 매커니즘을 이용해서 비슷한 부분을 공통의 슈퍼클래스로 옮겨 담을 수 있다.



<br/>

## 12.9. 계층 합치기

### 배경

- 계층구조도 진화하면서 어떤 클래스와 부모가 너무 비슷해져서 더는 독립적으로 존재해야할 이유가 사라지는 경우 그둘을 합쳐야할 시점이다.



<br/>

## 12.10. 서브클래스를 위임으로 바꾸기

### 배경

- 상속에는 단점이 있다. 한번만 쓸 수 있는 카드라는 것이다.
- 가장 명확한 단점은 무언가가 달라져야 하는 이유가 여러 개여도 상속에서는 그중 단 하나의 이유만으로 선택해 기준으로 삼을 수 밖에 없다.
- 또한 상속은 클래스들의 관계를 아주 긴밀하게 결합한다.
  - 부모를 수정하면 이미 존재하는 자식들의 기능을 해치기 쉽기 떄문에 각별히 주의해야 한다.

- 위임은 이상의 두 문제를 모두 해결해준다.

  > (클래스) 상속보다는 (객체) 컴포지션을 사용하라!



<br/>

## 12.11. 슈퍼클래스를 위임으로 바꾸기

### 배경

- 자바의 스택은 슈퍼클래스를 위임으로 바꾸는 이번 리팩터링을 적용해야하는 좋은 예다.
- 슈퍼클래스의 기능들이 서브클래스에는 어울리지 않는다면 그 기능들을 상속을 통해 이용하면 안 된다는 신호다.

